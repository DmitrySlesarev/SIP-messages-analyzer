#-*-coding: utf-8-*-  

import re
from sys import argv
from sys import exit
from os.path import exists


class Decoration():

    def start(self, func):
        ## this function wraps initial text  
        print("="*20)
        print(func.upper())
        print("="*20)

    def finish(self):
        ## this function finishes text  
        print("-"*20)
        print("FINISHED\n")


class Entry_point(Decoration):

    def __init__(self):
        print("""This script analyzes content of Session Initiation Protocol in \
             accordance with RFC's:3265, 3853, 4320, 4916, 5393, 5621, 5626, 5630, 5922,\
             5954, 6026, 6141, 6665, 6878, 7462, 7463, 8217, 8591\n""")

    def enter(self):
        print("""Type the name of .txt(!) file with single(!) SIP message to analyse:""")
        name_of_file = str(input("> "))
        with open(name_of_file, "r+") as f:
            message = str(f.read())
        return message

    def processing_file(self):
        while True:
            try:
                message = self.enter()
                self.start("STARTING ANALYSIS")
                print(message)
                break
            except NameError as ex:
                print("Caught the EOF error:{0}".format(ex))
                print("Wrong name. Let's try again.")		
                continue
            except EOFError as ex:
                print("Caught the EOF error:{0}".format(ex))
                print("Wrong name. Let's try again.")
                continue
            except IOError as ex:
                print("Caught the I/O error:{0}".format(ex))
                print("Wrong name. Let's try again.")
                continue	
        return message        


class Options(Entry_point):

    def header_verification(self, arg):
        ## The Function checks if the headers comply RFC 3261 
        self.arg = arg
         
        headers_list = {
            'via' : 'Via',
            'max_forwards' : 'Max-Forwards',
            'to' : 'To',
            'from' : 'From',
            'call_id' : 'Call-ID',
            'cseq' : 'CSeq',
            }

        headers_invite = headers_list.copy()
        headers_invite['contact'] = 'Contact'

        self.start("Headers check:")
        if re.search('INVITE', self.arg):
            for key in headers_invite:
                if re.search(headers_invite[key], self.arg):
                    print(key.upper(), True)
                else:
                    print(headers_invite[key].upper(), False)	
        else:
            for key in headers_list:
                if re.search(headers_list[key], self.arg):
                    print(key.upper(), True)
                else:
                    print(headers_list[key], False)
        self.finish()


    def client_verification(self, arg):
        ## The Function checks if there are any Client Errors  
        self.arg = arg        

        client_errors = {
            'bad_request' : '(400)',
            'unathorized' : '(401)',
            'forbidden' : '(403)',
            'not_found' : '(404)',
            'proxy_authentication_required' : '(407)',
            'request_timeout' : '(408)',
            'temporary_unavailable' : '(480)',
            'call_or_transaction_does_not_exist' : '(481)',
            'busy_here' : '(486)',
            'request_terminated' : '(487)',
            }

        self.start("Errors of Client:")
        for key in client_errors:
                if re.search(client_errors[key], self.arg):
                    print(key.upper(), True)
                else:
                    print(client_errors[key].upper(), False)
        self.finish()


    def server_verification(self, arg):
        ## The Function checks if there are any Server Errors  
        self.arg = arg

        server_errors = {
            'bad_gateway' : '(502)',
            'service_unavailable' : '(503)',
            }

        self.start("Server errors:")
        for key in server_errors:
            if re.search(server_errors[key], self.arg):
                print(key.upper(), True)
            else:
                print(server_errors[key].upper(), False)
        self.finish()


    def global_errors_verification(self, arg):
        ## The Function checks if there are any Global Errors  
        self.arg = arg

        global_errors = {
            'busy_everywhere' : '(600)', 
            'decline' : '(603)',
        }

        self.start("Global errors:")
        for key in global_errors:
            if re.search(global_errors[key], self.arg):
                print(key.upper(), True)
            else:
                print(global_errors[key].upper(), False)	
        self.finish()


    def phone_context_verification(self, arg):
        ## The Function checks the phone-context attribute  
        self.arg = arg

        self.start("Phone context check:")
        
        phone_context = [
            '.i-wlan.ims.mnc',
            ]
        for i in phone_context:
            if i in self.arg:
                print("""In accordance with Megafon NW requirements, 
                     the FQDN cannot have WiFi MAC address & i-wlan string.\n
                     PROHIBITED:\n
                     INVITE sip:89262000099;phone-context=d460e3ed8420.i-wlan.ims.mnc002.mcc250.3gppnetwork.org@ims.mnc002.mcc250.3gppnetwork.org;user=phone SIP/2.0\n
                     REQUIRED:\n
                     phone-context=ims.mnc002.mcc250.3gppnetwork.org@ims.mnc002.mcc250.3gppnetwork.org\n
                     Please, comply.""")
            else:
                print("Phone context matches the requirements")
        self.finish()


    def crosscheck(self, arg):
    	## The functions doesn't comply PEP8 intentionally  
        self.arg = arg

        self.start("Crosscheck:")
        print('Complies RFC 3261') if re.search('z9hG4bK', self.arg) else print('Doesn\'t comply RFC 3261')
        print('GEO PIDF is present') if re.search('<gml:pos>', self.arg) else print('Doesn\'t comply AOSA')
        print('EVS is allowed') if re.search('EVS', self.arg) else print('No EVS codec')
        print('SDP is checked') if re.search('sendrecv', self.arg) else print('Check SDP: no bilateral voice')
        print('P-Early-Media:supported') if re.search('P-Early-Media: supported', self.arg) else print('P-Early-Media: NOT supported')
        print('P-Access-Network-Info: IEEE-802.11') if re.search('P-Access-Network-Info: IEEE-802.11', self.arg) else print('No VoWiFi PANI')
        print('Cellular-Network-Info: 3GPP-E-UTRAN') if re.search('Cellular-Network-Info: 3GPP-E-UTRAN', self.arg) else print('No CNI for VoWiFi')
        self.finish()	


class Action(Options):

    def action_points(self):
        
        list_of_functions = {
           'header_verification' : 'Header verification',
            'client_verification' : 'Client Errors verification',
            'server_verification' : 'Server Errors verification',
            'global_errors_verification' : 'Global Errors verification',
            'phone_context': 'Attribute verification',
            'crosshcheck' : 'Crosscheck',
            'all' : 'All above mentioned items',
            'exit' : "EXIT"
            }

        argument = self.processing_file()

        while True:
            self.start("Available options:")
            index = 1
            for key in list_of_functions:
                print("{}.".format(index), list_of_functions[key])
                index+=1
            print("\nEnter any number from the options:")
        
            next = int(input(">"))
            '''
            assert type(next) != str, "Should be int"   
            assert type(next) != float, "Should be int"  
            assert type(next) != bool, "Should be int"  
            assert type(next) != None, "Should not be empty"  
            '''
            try:
                if next == int(1): self.header_verification(argument)
                if next == int(2): self.client_verification(argument)
                if next == int(3): self.server_verification(argument)
                if next == int(4): self.global_errors_verification(argument)
                if next == int(5): self.phone_context_verification(argument)
                if next == int(6): self.crosscheck(argument)
                if next == int(7): print("Under construction.")
                if next == int(8): exit(1)
            except Exception as ex:
                print("The input contains wrong symbol(s):{}".format(ex))
                print("Please, try again.")    

class End(Entry_point):

	def __init__(self):
		pass

if __name__ == "__main__":
    new = Action()
    new.action_points()
